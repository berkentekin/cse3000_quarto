---
title: "ITUExperiment"
format: pdf
---

---
title: "ITUExperiment"
---

### Install required Libraries

```{r libraries}
library("tidyverse")
library("ggpmisc")
library("pcaPP")
library("VGAM")
library("purrr")
library("MonoPoly")
library("minpack.lm")

```

### Helper constants, functions and operators

```{r}

snr_order <- c("n4", "n2", "0", "2", "4", "6", "8", "Q")

read_as_tibble <- function(filepath, sep = ",") {
  read.csv(filepath, sep = sep) %>% as_tibble()
}

noq <- function(data) {
  data %>% filter(snr != 'Q')
}

`%sp%` <- function(df, val) {
  filter(df, speaker == val)
}

`%snr%` <- function(df, val) {
  filter(df, snr == val)
}

tidier <- function(data) {
  data <- data %>% noq() %>% mutate(snr = factor(snr,snr_order)) %>% mutate(
    snr = as.numeric(gsub("^n", "-", as.character(snr))))
}

richards_start <- c(
  B = 0.04,
  M = 0.75,
  Q = 1
  
)

gomp <- function(d, a, b, c) {
  a * exp(-1 * b * exp(-1 * c * d))
}

logistic_taal10 <- function(d, a, b) {
  1 / (1 + exp(a * d + b))
}

logistic_gen <- function(d, a, b, c) {
  (1 - c) / (1 + exp(a * d + b))
}

logistic_gen2 <- function(d, a, b, c, h) {
  h + ( (1 - c) / (1 + exp(a * d + b)) )
}

dau_taal10 <- function(d, a, b, c) {
  1 / (1 + (a*d + b)^ c)
}
```

### Read observations for ALLSSTAR

```{r csv_readers}


prepare_allsstar <- function(metadata_csv_loc, ...) {
  # Helper function to read CSV files and convert them to tibbles

  
  # Gather the additional score file paths
  scores <- list(...)
  
  # Read the input files
  l1_data <- read_as_tibble(metadata_csv_loc, sep = ";")
  l1_stoi_scores <- read_as_tibble(scores[["stoi_scores_loc"]])
  l1_miknn_scores <- read_as_tibble(scores[["miknn_scores_loc"]])
  l1_siib_scores <- read_as_tibble(scores[["siib_scores_loc"]])
  l1_siib_scores_gaussian <- read_as_tibble(scores[["siib_scores_gaussian_loc"]])
  l1_siib_scores_gaussian_gapped <- read_as_tibble(scores[["siib_scores_gaussian_gapped_loc"]])
  
  # Merge all data
  allsstar_data <- l1_data %>%
    merge(l1_stoi_scores, by.x = c("audio", "snr"), by.y = c("filename", "snr"), all.x = TRUE) %>%
    merge(l1_miknn_scores, by.x = c("audio", "snr"), by.y = c("CleanFile", "Degradation"), all.x = TRUE) %>%
    merge(l1_siib_scores, by.x = c("audio", "snr"), by.y = c("filename", "snr"), all.x = TRUE) %>%
    merge(l1_siib_scores_gaussian, by.x = c("audio", "snr"), by.y = c("filename", "snr"), all.x = TRUE) %>%
    merge(l1_siib_scores_gaussian_gapped, by.x = c("audio", "snr"), by.y = c("filename", "snr"), all.x = TRUE)
  
  # Perform additional transformations
  allsstar_data <- allsstar_data %>% tidier() %>%
    rename(stoi_score = score) %>%
    #filter(trial > 3) %>%
    replace_na(list(stoi_score = 1)) %>%
    mutate(sim_wcr = autoscore / numwords) %>%
    mutate(parent_filename = sub("_S[0-9]+$", "", audio))
  
  # Return the final data
  return(allsstar_data)
}

prepare_dantale <- function(dantale_data, dantale_conditions, dantale_trials, dantale_oim) {
  
  
  dantale_oim <- dantale_oim %>% mutate(snr = as.numeric(snr), cond = as.numeric(cond), trial = as.numeric(trial))

  dantale_all <- dantale_data %>%
    merge(dantale_oim, by.x=c("experiment", "cond", "snr_no"), by.y=c("experiment", "cond", "snr"), all.x = TRUE, all.y = TRUE)
  
  dantale_all <- dantale_all %>% group_by(experiment,cond, snr) %>% summarise(
    experiment = first(experiment),
    across(
      everything(),
      ~ mean(.x, na.rm = TRUE),                  # The function to apply
      .names = "avg_{.col}"                      # How to name the resulting columns
    )
  ) %>% merge(
    dantale_conditions, by.x=c("experiment", "cond"), by.y=c("experiment", "cond")
  ) %>% mutate(snr = as.factor(snr)) %>%  filter(experiment != 'the_experiment_Training')

}

dantale_data <- read_csv("data/dantale_data.csv")
dantale_conditions <- read_csv("data/dantale_conditions.csv")
dantale_trials <- read_csv("data/dantale_trials.csv")
dantale_oim <- read_csv("data/dantale_results.csv")
dantale_other <- read_csv("data/dantale_results_other.csv")
dantale_miknn <- read_csv("data/dantale_results_miknn_2.csv")
dantale_oim <- dantale_oim %>% merge(dantale_other) %>% merge(dantale_miknn)
dantale_all <- prepare_dantale(dantale_data,dantale_conditions, dantale_trials, dantale_oim) 


```

```{r create-allsstar-df}
allsstar_data <- prepare_allsstar(metadata_csv_loc = "data/l1res.csv",
                 stoi_scores_loc="data/stoi_scores.csv",
                 miknn_scores_loc="data/miknn_scores.csv",
                 siib_scores_loc="data/siib_scores.csv",
                 siib_scores_gaussian_loc="data/siib_scores_gaussian.csv",
                 siib_scores_gaussian_gapped_loc="data/siib_scores_gaussian_gapped.csv")

all_data <- dantale_all %>% merge(allsstar_data)
```

```{r}

adj_first_formula <- function(data, wcr) {
  
  calc_ab <- function(data, wcr, oim) {
    N <- nrow(data)
    mult <- data[[{wcr}]] * data[[{oim}]]
    b1 <- N * sum(mult) - sum(data[[{wcr}]]) * sum(data[[{oim}]])
    b2 <- N * sum(data[[{wcr}]]^2) - sum(data[[{wcr}]])^2
    b <- b1 / b2 # slope
    a <- (sum(data[[{oim}]]) - b * sum(data[[{wcr}]])) / N # intercept
    
    return(list(a = a, b = b))
  }
  
  stoi_ab <- data %>% calc_ab(wcr, 'avg_stoi')
  miknn_ab <- data %>% calc_ab(wcr, 'avg_miknn')
  print(stoi_ab)
  
  data <- data %>% mutate(adj_stoi_wcr = stoi_ab$a + stoi_ab$b * .[[{wcr}]],
                      adj_miknn_wcr = miknn_ab$a + miknn_ab$b * .[[{wcr}]]    )

}

ad_grp_snr_gender <- allsstar_data %>% group_by(snr, gender) %>% summarise(avg_wcr=mean(sim_wcr), avg_stoi = mean(stoi_score),  avg_siib=mean(siib_score_gaussian_gapped), avg_miknn=mean(MIKNNScore2x), .groups = "drop")

ad_grp_adj_snr_gender <- ad_grp_snr_gender %>% adj_first_formula('avg_wcr')

ggplot(data=ad_grp_adj_snr_gender, aes(x=avg_miknn, y=adj_miknn_wcr, color=snr)) + geom_point()
```

```{r}

adj_first_formula <- function(data, wcr, outcome_vars) {
  
  # Helper function to calculate intercept (a) and slope (b)
  calc_ab <- function(data, wcr, outcome_var) {
    N <- nrow(data)
    mult <- data[[wcr]] * data[[outcome_var]]
    b1 <- N * sum(mult) - sum(data[[wcr]]) * sum(data[[outcome_var]])
    b2 <- N * sum(data[[wcr]]^2) - sum(data[[wcr]])^2
    b <- b1 / b2  # slope
    a <- (sum(data[[outcome_var]]) - b * sum(data[[wcr]])) / N  # intercept
    
    return(data.frame(outcome_var = outcome_var, a = a, b = b))
  }
  
  # Calculate a and b for each outcome variable and combine into a dataframe
  ab_df <- purrr::map_dfr(outcome_vars, ~calc_ab(data, wcr, .x))
  
  # Adjust the data with calculated intercept and slope for each variable
  for (var in outcome_vars) {
    coefs <- ab_df %>% filter(outcome_var == var)
    print(coefs)
    data <- data %>% mutate(!!paste0("adj_", var, "_", wcr) := coefs$a + coefs$b * .[[wcr]])
  }
  
  return(data)
}

# Example Usage
ad_grp_snr_gender_2 <- allsstar_data %>%
  group_by(snr, gender) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )


fit_stoi <- lm(formula=avg_stoi ~ avg_wcr, data=ad_grp_snr_gender_2)
fit_miknn <- lm(formula=avg_siib ~ avg_wcr, data=ad_grp_snr_gender_2)
fit_siib <- lm(formula=avg_miknn ~ avg_wcr, data=ad_grp_snr_gender_2)

stoi_coefs <- coef(fit_stoi)
miknn_coefs <- coef(fit_miknn)
siib_coefs <- coef(fit_siib)

all_coefs <- rbind(stoi_coefs, miknn_coefs, siib_coefs)
colnames(all_coefs) <- c('a', 'b') # a: Intercept, b: slope

```

```{r}

AICc <- function(fit, n, k) {
  AIC(fit) +  (2*(k^2) + 2*k) / (n - k - 1)
}

# Example Usage
data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )

linear_stoi_fit <- lm(data=data_group_by_snr_gender, formula=avg_wcr ~ avg_stoi)
poly3_stoi_fit <- MonoPoly::monpol(formula = avg_wcr ~ avg_stoi, data= data_group_by_snr_gender, degree = 3)
dau_stoi_fit <- nlsLM(avg_wcr ~ dau_taal10(avg_stoi, a, b, c), data = data_group_by_snr_gender, start=c(a=0,b=1,c=0.5))
logist_stoi_fit <- nls(avg_wcr ~ logistic_taal10(avg_stoi, a, b), data = data_group_by_snr_gender, start=c(a=0,b=0.5))

summary(linear_stoi_fit)
summary(poly3_stoi_fit)
summary(dau_stoi_fit)
summary(logist_stoi_fit)




data_group_by_snr_gender <- data_group_by_snr_gender %>%
  mutate(poly3_stoi_fit = predict(poly3_stoi_fit, newdata = data_group_by_snr_gender),
         dau_stoi_fit = predict(dau_stoi_fit, newdata = data_group_by_snr_gender),
         linear_stoi_fit = predict(linear_stoi_fit, newdata = data_group_by_snr_gender),
         logist_stoi_fit = predict(logist_stoi_fit, newdata = data_group_by_snr_gender))



AICc(linear_stoi_fit, n=14, k=2) # Converges to AIC -28.2839
AICc(poly3_stoi_fit, n=14, k=4) # -24.60715
AICc(dau_stoi_fit, n=14, k=3) # -28.9996
AICc(logist_stoi_fit, n=14, k=length(coef(logist_stoi_fit))) # -32.2805 best fit
 
BIC(linear_stoi_fit) # -27.45764
BIC(poly3_stoi_fit) # -25.85631
BIC(dau_stoi_fit) # -28.84337
BIC(logist_stoi_fit) # -31.45423 best fit


# Plot the scatter plot and fit line using ggplot2
ggplot(data_group_by_snr_gender, aes(x = avg_stoi, y = avg_wcr)) +
  geom_point(color = "blue", size = 2) +
  geom_line(aes(y = poly3_stoi_fit), color = "red", linewidth = 1) +
  geom_line(aes(y = dau_stoi_fit), color = "brown", linewidth = 1) +
  geom_line(aes(y = linear_stoi_fit), color = "green", linewidth = 1) +
  geom_line(aes(y = logist_stoi_fit), color = "purple", linewidth = 1) +
  labs(
    title = "Varoius fits on data grouped by SNR and Gender",
    x = "Average STOI",
    y = "Average WCR"
  )


```

```{r miknn}


# Example Usage
data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr, gender) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )

linear_miknn_fit <- lm(data=data_group_by_snr_gender, formula=avg_wcr ~ avg_miknn)
poly3_miknn_fit <- MonoPoly::monpol(formula = avg_wcr ~ avg_miknn, data= data_group_by_snr_gender, degree = 3)
dau_miknn_fit <- nlsLM(avg_wcr ~ dau_taal10(avg_miknn, a, b, c), data = data_group_by_snr_gender, start=c(a=0,b=1,c=0.5))
logist_miknn_fit <- nls(avg_wcr ~ logistic_taal10(avg_miknn, a, b), data = data_group_by_snr_gender, start=c(a=0,b=0.5))


summary(linear_miknn_fit)
summary(poly3_miknn_fit)
summary(dau_miknn_fit)
summary(logist_miknn_fit)




data_group_by_snr_gender <- data_group_by_snr_gender %>%
  mutate(poly3_miknn_fit = predict(poly3_miknn_fit, newdata = data_group_by_snr_gender),
         dau_miknn_fit = predict(dau_miknn_fit, newdata = data_group_by_snr_gender),
         linear_miknn_fit = predict(linear_miknn_fit, newdata = data_group_by_snr_gender),
         logist_miknn_fit = predict(logist_miknn_fit, newdata = data_group_by_snr_gender))



AICc(linear_miknn_fit, n=14, k=2) # Converges to AIC -28.2839 best fit
AICc(poly3_miknn_fit, n=14, k=4) # -18.391
AICc(dau_miknn_fit, n=14, k=3) # -22.7138
AICc(logist_miknn_fit, n=14, k=length(coef(logist_miknn_fit))) # -25.97967

 
BIC(linear_miknn_fit) # -21.8263
BIC(poly3_miknn_fit) # -19.64016
BIC(dau_miknn_fit) # -22.55757
BIC(logist_miknn_fit) # -25.1534 best fit
 

# Plot the scatter plot and fit line using ggplot2
ggplot(data_group_by_snr_gender, aes(x = avg_miknn, y = avg_wcr)) +
  geom_point(color = "blue", size = 2) +
  geom_line(aes(y = poly3_miknn_fit), color = "red", linewidth = 1) +
  geom_line(aes(y = dau_miknn_fit), color = "brown", linewidth = 1) +
  geom_line(aes(y = linear_miknn_fit), color = "green", linewidth = 1) +
  geom_line(aes(y = logist_miknn_fit), color = "purple", linewidth = 1) +
  labs(
    title = "Varoius fits on data grouped by SNR and Gender",
    x = "Average MIKNN",
    y = "Average WCR"
  )


```

```{r siib}


# Example Usage
data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )

linear_siib_fit <- lm(data=data_group_by_snr_gender, formula=avg_wcr ~ avg_siib)
poly3_siib_fit <- MonoPoly::monpol(formula = avg_wcr ~ avg_siib, data= data_group_by_snr_gender, degree = 3)
dau_siib_fit <- nlsLM(avg_wcr ~ dau_taal10(avg_siib, a, b, c), data = data_group_by_snr_gender, start=c(a=0,b=1,c=0.5))
logist_siib_fit <- nls(avg_wcr ~ logistic_taal10(avg_siib, a, b), data = data_group_by_snr_gender, start=c(a=0,b=0.5))


summary(linear_siib_fit)
summary(poly3_siib_fit)
summary(dau_siib_fit)
summary(logist_siib_fit)




data_group_by_snr_gender <- data_group_by_snr_gender %>%
  mutate(poly3_siib_fit = predict(poly3_siib_fit, newdata = data_group_by_snr_gender),
         dau_siib_fit = predict(dau_siib_fit, newdata = data_group_by_snr_gender),
         linear_siib_fit = predict(linear_siib_fit, newdata = data_group_by_snr_gender),
         logist_siib_fit = predict(logist_siib_fit, newdata = data_group_by_snr_gender))



AICc(linear_siib_fit, n=7, k=2) # Converges to AIC -25.4314 
AICc(poly3_siib_fit, n=7, k=4) # -40.99456
AICc(dau_siib_fit, n=7, k=3) # -38.80655
AICc(logist_siib_fit, n=7, k=length(coef(logist_siib_fit))) # -42.21727 best fit

 
BIC(linear_siib_fit) # -24.60514
BIC(poly3_siib_fit) # -42.24372 best fit
BIC(dau_siib_fit) # -38.65032
BIC(logist_siib_fit) # -41.39101 
 

# Plot the scatter plot and fit line using ggplot2
ggplot(data_group_by_snr_gender, aes(x = avg_siib, y = avg_wcr)) +
  geom_point(color = "blue", size = 2) +
  geom_line(aes(y = poly3_siib_fit), color = "red", linewidth = 1) +
  geom_line(aes(y = dau_siib_fit), color = "brown", linewidth = 2) +
  geom_line(aes(y = linear_siib_fit), color = "green", linewidth = 1) +
  geom_line(aes(y = logist_siib_fit), color = "purple", linewidth = 1) +
  labs(
    title = "Varoius fits on data grouped by SNR and Gender",
    x = "Average SIIB",
    y = "Average WCR"
  )

```

# GPT Magic

```{r allstar-miknn}

library(tidyverse)
library(MonoPoly)
library(minpack.lm)

data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )

# Fit your models as before...
linear_miknn_fit <- lm(data=data_group_by_snr_gender, formula=avg_wcr ~ avg_miknn)
poly3_miknn_fit  <- MonoPoly::monpol(formula = avg_wcr ~ avg_miknn, data= data_group_by_snr_gender, degree = 3)
dau_miknn_fit    <- nlsLM(avg_wcr ~ dau_taal10(avg_miknn, a, b, c),
                          data = data_group_by_snr_gender,
                          start=c(a=0,b=1,c=0.5))
logist_miknn_fit <- nls(avg_wcr ~ logistic_taal10(avg_miknn, a, b),
                        data = data_group_by_snr_gender,
                        start=c(a=0,b=0.5))

# Collect predicted values
data_group_by_snr_gender <- data_group_by_snr_gender %>%
  mutate(
    poly3_miknn_fit   = predict(poly3_miknn_fit, newdata = data_group_by_snr_gender),
    dau_miknn_fit     = predict(dau_miknn_fit,   newdata = data_group_by_snr_gender),
    linear_miknn_fit  = predict(linear_miknn_fit,newdata = data_group_by_snr_gender),
    logist_miknn_fit  = predict(logist_miknn_fit,newdata = data_group_by_snr_gender)
  )

# Compute AICc for each model (or BIC if you prefer):
AICc_linear <- AICc(linear_miknn_fit,  n=14, k=2)
AICc_poly3  <- AICc(poly3_miknn_fit,   n=14, k=4)
AICc_dau    <- AICc(dau_miknn_fit,     n=14, k=3)
AICc_logist <- AICc(logist_miknn_fit,  n=14, k=length(coef(logist_miknn_fit)))

# Reshape to long format for easier ggplot usage
plot_data <- data_group_by_snr_gender %>%
  select(avg_miknn, avg_wcr,
         poly3_miknn_fit,
         dau_miknn_fit,
         linear_miknn_fit,
         logist_miknn_fit) %>%
  pivot_longer(
    cols = c(poly3_miknn_fit, dau_miknn_fit, linear_miknn_fit, logist_miknn_fit),
    names_to = "model",
    values_to = "fitted"
  )

# Now plot with a single geom_line, colored by model
ggplot(plot_data, aes(x = avg_miknn, y = avg_wcr)) +
  geom_point(color="blue", size = 2) +
  geom_line(aes(y = fitted, color = model), size = 1) +
    scale_y_continuous(
    name   = "Average WCR (%)",
    labels = function(x) x * 100
  ) +
  # Put the AICc values (or BIC) into the legend labels:
  scale_color_manual(
    name = "Model Fit",
    values = c(
      "linear_miknn_fit" = "green",
      "poly3_miknn_fit"  = "red",
      "dau_miknn_fit"    = "brown",
      "logist_miknn_fit" = "purple"
    ),
    labels = c(
      "linear_miknn_fit" = paste0("Linear (AICc=", round(AICc_linear, 2), ")"),
      "poly3_miknn_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")"),
      "dau_miknn_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")"),
      "logist_miknn_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")")
    )
  ) +
  labs(
    title = "Various fits on data grouped by SNR and Gender",
    x = "Average MIKNN",
    y = "Average WCR"
  ) +
  theme_minimal()
```

```{r allsstar-stoi}
library(tidyverse)
library(MonoPoly)
library(minpack.lm)

data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi = mean(stoi_score),
    avg_siib = mean(siib_score_gaussian_gapped),
    avg_miknn = mean(MIKNNScore2x),
    .groups = "drop"
  )

# Fit your models as before...
linear_stoi_fit <- lm(data=data_group_by_snr_gender, formula=avg_wcr ~ avg_stoi)
poly3_stoi_fit  <- MonoPoly::monpol(formula = avg_wcr ~ avg_stoi, data= data_group_by_snr_gender, degree = 3)
dau_stoi_fit    <- nlsLM(avg_wcr ~ dau_taal10(avg_stoi, a, b, c),
                          data = data_group_by_snr_gender,
                          start=c(a=0,b=1,c=0.5))
logist_stoi_fit <- nls(avg_wcr ~ logistic_taal10(avg_stoi, a, b),
                        data = data_group_by_snr_gender,
                        start=c(a=0,b=0.5))

# Collect predicted values
data_group_by_snr_gender <- data_group_by_snr_gender %>%
  mutate(
    poly3_stoi_fit   = predict(poly3_stoi_fit, newdata = data_group_by_snr_gender),
    dau_stoi_fit     = predict(dau_stoi_fit,   newdata = data_group_by_snr_gender),
    linear_stoi_fit  = predict(linear_stoi_fit,newdata = data_group_by_snr_gender),
    logist_stoi_fit  = predict(logist_stoi_fit,newdata = data_group_by_snr_gender)
  )

# Compute AICc for each model (or BIC if you prefer):
AICc_linear <- AICc(linear_stoi_fit,  n=14, k=2)
AICc_poly3  <- AICc(poly3_stoi_fit,   n=14, k=4)
AICc_dau    <- AICc(dau_stoi_fit,     n=14, k=3)
AICc_logist <- AICc(logist_stoi_fit,  n=14, k=length(coef(logist_stoi_fit)))

# Reshape to long format for easier ggplot usage
plot_data <- data_group_by_snr_gender %>%
  select(avg_stoi, avg_wcr,
         poly3_stoi_fit,
         dau_stoi_fit,
         linear_stoi_fit,
         logist_stoi_fit) %>%
  pivot_longer(
    cols = c(poly3_stoi_fit, dau_stoi_fit, linear_stoi_fit, logist_stoi_fit),
    names_to = "model",
    values_to = "fitted"
  )

# Now plot with a single geom_line, colored by model
ggplot(plot_data, aes(x = avg_stoi, y = avg_wcr)) +
  geom_point(color="blue", size = 2) +
  geom_line(aes(y = fitted, color = model), size = 1) +
    scale_y_continuous(
    name   = "Average WCR (%)",
    labels = function(x) x * 100
  ) +
  # Put the AICc values (or BIC) into the legend labels:
  scale_color_manual(
    name = "Model Fit",
    values = c(
      "linear_stoi_fit" = "green",
      "poly3_stoi_fit"  = "red",
      "dau_stoi_fit"    = "brown",
      "logist_stoi_fit" = "purple"
    ),
    labels = c(
      "linear_stoi_fit" = paste0("Linear (AICc=", round(AICc_linear, 2), ")"),
      "poly3_stoi_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")"),
      "dau_stoi_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")"),
      "logist_stoi_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")")
    )
  ) +
  labs(
    title = "Various fits on data grouped by SNR and Gender",
    x = "Average stoi",
    y = "Average WCR"
  ) +
  theme_minimal()
```
# Final_graphs function
```{r allsstar-siib}
library(tidyverse)
library(MonoPoly)
library(minpack.lm)
library(LaplacesDemon)

final_graphs_arb <- function(dataset_grouped, col_name_string, formula) {
  
  fit <- nls(
    formula, 
    data = dataset_grouped, 
    start = c(b=1, c=-0.01)
  )
  
  rmse <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(fit, newdata = dataset_grouped))^2))
  
  aic <- 
  
}

final_graphs <- function(dataset_grouped, n, col_name_string) {
  
  # Build a formula from the string, e.g. "avg_siib_gaussian"
  my_formula <- as.formula(paste("avg_wcr ~", col_name_string))
  my_poly3_formula <- as.formula(paste("avg_wcr ~ poly(", col_name_string, ", 3, raw=TRUE)"))
  my_poly2_formula <- as.formula(paste("avg_wcr ~ poly(", col_name_string, ", 5, raw=TRUE)"))
    print(1)

  my_gomp_formula <- as.formula(paste("avg_wcr ~ gomp(", col_name_string,", 1, b, c)"))
    print(1)

  # Fit models using that formula
  linear_fit <- lm(data = dataset_grouped, formula = my_formula)
  print(1)
  
  poly3_mon_fit  <- monpol(my_formula, data = dataset_grouped, degree = 3)
  poly2_mon_fit  <- monpol(my_formula, data = dataset_grouped, degree = 5)
  print(1)
  
  dau_fit    <- nlsLM(
    as.formula(paste("avg_wcr ~ dau_taal10(", col_name_string, ", a, b, c)")),
    data  = dataset_grouped,
    start = c(a = 0, b = 1, c = 0.5)
  )
  logist_fit <- nls(
    as.formula(paste("avg_wcr ~ logistic_taal10(", col_name_string, ", a, b)")),
    data  = dataset_grouped,
    start = c(a = 0, b = 0.5)
  )
  print(gomp(dataset_grouped %>% pull(col_name_string), 1, 1, -0.01))
  gomp_fit <- nls(
    my_gomp_formula, 
    data = dataset_grouped, 
    start = c(b=1, c=-0.01)
  )

  
  
  print(1)
  poly3_fit <- lm(my_poly3_formula, data = dataset_grouped)  
  print(1)
   # Compute RMSE (Root Mean Squared Error)
  rmse_linear <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(linear_fit, newdata = dataset_grouped))^2))
  rmse_poly3_mon  <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(poly3_mon_fit, newdata = dataset_grouped))^2))
    rmse_poly3  <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(poly3_fit, newdata = dataset_grouped))^2))
  rmse_dau    <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(dau_fit, newdata = dataset_grouped))^2))
  rmse_logist <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(logist_fit, newdata = dataset_grouped))^2))
    rmse_gomp <- sqrt(mean((dataset_grouped$avg_wcr -
                            predict(gomp_fit, newdata = dataset_grouped))^2))
  
  AIC_linear <- AIC(linear_fit)
  AIC_poly3_mon <- AIC(poly3_mon_fit)
  AIC_dau <- AIC(dau_fit)
  AIC_logist <- AIC(logist_fit)
  AIC_poly3 <- AIC(poly3_fit)
  AIC_gomp <- AIC(gomp_fit)


  # Compute AICc
  AICc_linear <- AICc(linear_fit,  n = n, k = length(coef(linear_fit)))
  AICc_poly3_mon  <- AICc(poly3_mon_fit,   n = n, k = length(coef(poly3_mon_fit)))
  AICc_poly3  <- AICc(poly3_fit,   n = n, k = length(coef(poly3_fit)))
  AICc_dau    <- AICc(dau_fit,     n = n, k = length(coef(dau_fit)))
  AICc_logist <- AICc(logist_fit,  n = n, k = length(coef(logist_fit)))
  AICc_gomp <- AICc(gomp_fit, n = n, k = length(coef(gomp_fit)))

  min_AICc <- min(c(AICc_linear, AICc_logist, AICc_poly3_mon, AICc_dau, AICc_gomp))
    
  # Create a tibble with labeled columns
  AICc_df <- tibble(
    Model = c("Linear", "poly3_mon", "Dau", "Logistic", "Gomp"),
    AICc = c(AICc_linear, AICc_poly3_mon,  AICc_dau, AICc_logist, AICc_gomp),
    d_AICc = c(AICc_linear, AICc_poly3_mon, AICc_dau, AICc_logist, AICc_gomp) - min_AICc
  ) %>% mutate(d_lik = exp(-d_AICc / 2), d_lik_weigh = d_lik / sum(d_lik))
  print(AICc_df)

  
  # Compute PCC
   pcc_linear  <- cor(dataset_grouped$avg_wcr,
                     predict(linear_fit, newdata = dataset_grouped))
  
  pcc_poly3_mon   <- cor(dataset_grouped$avg_wcr,
                     predict(poly3_mon_fit, newdata = dataset_grouped))
    pcc_poly2_mon   <- cor(dataset_grouped$avg_wcr,
                     predict(poly2_mon_fit, newdata = dataset_grouped))
   pcc_poly3   <- cor(dataset_grouped$avg_wcr,
                     predict(poly3_fit, newdata = dataset_grouped)) 
  pcc_dau     <- cor(dataset_grouped$avg_wcr,
                     predict(dau_fit, newdata = dataset_grouped))
  
  pcc_logist  <- cor(dataset_grouped$avg_wcr,
                     predict(logist_fit, newdata = dataset_grouped))
    pcc_gomp  <- cor(dataset_grouped$avg_wcr,
                     predict(gomp_fit, newdata = dataset_grouped))
  
  # Compute Kendall's Tau
  ktau  <- cor(
    dataset_grouped$avg_wcr,
    predict(linear_fit, newdata = dataset_grouped),
    method = "kendall"
  )
  
  
  results <- data.frame(
  Model      = c("Linear", "poly3_mon", "Dau", "Logistic", "Gompertz"),
  RMSE =      c(rmse_linear, rmse_poly3_mon, rmse_dau, rmse_logist, rmse_gomp),
  AIC        = c(AIC_linear, AIC_poly3_mon, AIC_dau, AIC_logist, AIC_gomp),
  AICc       = c(AICc_linear, AICc_poly3_mon, AICc_dau, AICc_logist, AICc_gomp),
  PCC        = c(pcc_linear, pcc_poly3_mon, pcc_dau, pcc_logist, pcc_gomp),
  KendallTau = c(ktau, ktau, ktau, ktau, ktau)
  )
  
  print(results)
  
  # Create a grid
  x_min <- min(dataset_grouped[[col_name_string]])
  x_max <- max(dataset_grouped[[col_name_string]])
  x_seq <- seq(x_min, x_max, length.out = 200)
  
  # Build pred_df with a column name of col_name_string
  pred_df <- tibble(!!col_name_string := x_seq)
  
  # Predict
  pred_df <- pred_df %>%
    mutate(
      linear_fit  = predict(linear_fit,  newdata = pred_df),
      poly3_mon_fit   = predict(poly3_mon_fit,   newdata = pred_df),
      dau_fit     = predict(dau_fit,     newdata = pred_df),
      logist_fit  = predict(logist_fit,  newdata = pred_df),
      gomp_fit = predict(gomp_fit, newdata = pred_df)
            #poly3_fit   = predict(poly3_fit,   newdata = pred_df),

    )
  
  # Pivot longer
  plot_pred_df <- pred_df %>%
    pivot_longer(
      cols      = c(linear_fit, poly3_mon_fit,,
                    dau_fit,    logist_fit, gomp_fit),
      names_to  = "model",
      values_to = "fitted"
    )
  
  ggplot() +
    geom_point(
      data  = dataset_grouped,
      aes(x = .data[[col_name_string]], y = avg_wcr),
      color = "blue", size = 2
    ) +
    geom_line(
      data = plot_pred_df,
      aes(x = .data[[col_name_string]], y = fitted, color = model),
      size = 1
    ) +
    scale_y_continuous(
      name   = "WCR (%)",
      labels = function(x) x * 100
    ) +
    geom_label() +
    scale_color_manual(
      name = "Model Fit",
      values = c(
        "linear_fit" = "yellow",
        "poly3_mon_fit"  = "red",
        "poly2_mon_fit"  = "blue",
        "dau_fit"    = "brown",
        "logist_fit" = "purple",
        "gomp_fit" = "pink"
        #"poly3_fit" = "black"
      ),
      labels = c(
        "linear_fit" = paste0("Linear (AICc=",  round(AICc_linear, 2), ")", "(PCC=", round(pcc_linear, 2), ")"),
        "poly3_mon_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3_mon, 2), ")","(PCC=", round(pcc_poly3_mon, 2), ")"),
        "dau_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")","(PCC=", round(pcc_dau, 2), ")"),
        "logist_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")","(PCC=", round(pcc_logist, 2), ")"),
        "gompertz_fit" = paste0("Gompertz (AICc=", round(AICc_gomp, 2), ")","(PCC=", round(pcc_gomp, 2), ")")
        #"poly3_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")","(PCC=", round(pcc_poly3, 2), ")")

      )
    ) + annotate("label_npc", npcx="right", npcy="bottom", label = paste0(expression(tau)," = ", round(ktau,2)), fill = "lightgray") +
    labs(
      title = "Various fits on data grouped by Listening Conditions",
      x     = "STOI Score",
      y     = "WCR"
    ) +
    theme_minimal() 
  

}

# Call it like this (note the string):
data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi_score = mean(stoi_score),
    avg_siib_score_gaussian = mean(siib_score_gaussian_gapped),
    avg_siib_score = mean(siib_score_gaussian_gapped),
    avg_miknn_score = mean(MIKNNScore2x),
    .groups = "drop"
  ) %>% select(where(~ !any(is.na(.)))) %>% mutate(snr = as.factor(snr))

dantale_conds <- dantale_all %>% group_by(cond, snr) %>% summarise(across(everything(), ~ mean(.x, na.rm = TRUE)), .groups = "drop") %>%
  select(where(~ !any(is.na(.)))) %>% mutate(snr = as.factor(snr))

dat_all <- bind_rows(dantale_conds, data_group_by_snr_gender)

dat_allsstar <- data_group_by_snr_gender

final_graphs(dat_allsstar, nrow(dat_allsstar), "avg_siib_score_gaussian")
final_graphs(dat_allsstar, nrow(dat_allsstar), "avg_stoi_score")
final_graphs(dat_allsstar, nrow(dat_allsstar), "avg_miknn_score")

final_graphs(dat_all, nrow(dat_all), "avg_siib_score_gaussian")
final_graphs(dat_all, nrow(dat_all), "avg_stoi_score")
final_graphs(dat_all, nrow(dat_all), "avg_miknn_score")


# names(dantale_conds)

final_graphs(dantale_conds, nrow(dantale_conds), "avg_siib_score_gaussian")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_stoi_score")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_miknn_score")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_SNR")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_SegSNR")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_LLR")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_IS")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_CEP")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_STOI")
final_graphs(dantale_conds, nrow(dantale_conds), "avg_ESTOI")




```


```{r allsstar-siib}
library(tidyverse)
library(MonoPoly)
library(minpack.lm)
library(LaplacesDemon)

final_graphs_raw <- function(dataset_grouped, n, col_name_string) {
  
  # Build a formula from the string, e.g. "avg_siib_gaussian"
  my_formula <- as.formula(paste("sim_wcr ~", col_name_string))
  
  # Fit models using that formula
  linear_fit <- lm(data = dataset_grouped, formula = my_formula)
  poly3_fit  <- monpol(my_formula, data = dataset_grouped, degree = 3)
  dau_fit    <- nlsLM(
    as.formula(paste("sim_wcr ~ dau_taal10(", col_name_string, ", a, b, c)")),
    data  = dataset_grouped,
    start = c(a = 0, b = 1, c = 0.5)
  )
  logist_fit <- nls(
    as.formula(paste("sim_wcr ~ logistic_taal10(", col_name_string, ", a, b)")),
    data  = dataset_grouped,
    start = c(a = 0, b = 0.5)
  )
  
   # Compute RMSE (Root Mean Squared Error)
  rmse_linear <- sqrt(mean((dataset_grouped$sim_wcr -
                            predict(linear_fit, newdata = dataset_grouped))^2))
  rmse_poly3  <- sqrt(mean((dataset_grouped$sim_wcr -
                            predict(poly3_fit, newdata = dataset_grouped))^2))
  rmse_dau    <- sqrt(mean((dataset_grouped$sim_wcr -
                            predict(dau_fit, newdata = dataset_grouped))^2))
  rmse_logist <- sqrt(mean((dataset_grouped$sim_wcr -
                            predict(logist_fit, newdata = dataset_grouped))^2))
  
  AIC_linear <- AIC(linear_fit)
  AIC_poly3 <- AIC(poly3_fit)
  AIC_dau <- AIC(dau_fit)
  AIC_logist <- AIC(logist_fit)
  

  # Compute AICc
  AICc_linear <- AICc(linear_fit,  n = n, k = length(coef(linear_fit)))
  AICc_poly3  <- AICc(poly3_fit,   n = n, k = length(coef(poly3_fit)))
  AICc_dau    <- AICc(dau_fit,     n = n, k = length(coef(dau_fit)))
  AICc_logist <- AICc(logist_fit,  n = n, k = length(coef(logist_fit)))
  
  # Compute PCC
   pcc_linear  <- cor(dataset_grouped$sim_wcr,
                     predict(linear_fit, newdata = dataset_grouped))
  
  pcc_poly3   <- cor(dataset_grouped$sim_wcr,
                     predict(poly3_fit, newdata = dataset_grouped))
  
  pcc_dau     <- cor(dataset_grouped$sim_wcr,
                     predict(dau_fit, newdata = dataset_grouped))
  
  pcc_logist  <- cor(dataset_grouped$sim_wcr,
                     predict(logist_fit, newdata = dataset_grouped))
  
  # Compute Kendall's Tau
  ktau  <- cor(
    dataset_grouped$sim_wcr,
    predict(linear_fit, newdata = dataset_grouped),
    method = "kendall"
  )
  
  
  results <- data.frame(
  Model      = c("Linear", "Poly3", "Dau", "Logistic"),
  RMSE =      c(rmse_linear, rmse_poly3, rmse_dau, rmse_logist),
  AIC        = c(AIC_linear, AIC_poly3, AIC_dau, AIC_logist),
  AICc       = c(AICc_linear, AICc_poly3, AICc_dau, AICc_logist),
  PCC        = c(pcc_linear, pcc_poly3, pcc_dau, pcc_logist),
  KendallTau = c(ktau, ktau, ktau, ktau)
  )
  
  print(results)
  
  # Create a grid
  x_min <- min(dataset_grouped[[col_name_string]])
  x_max <- max(dataset_grouped[[col_name_string]])
  x_seq <- seq(x_min, x_max, length.out = 200)
  
  # Build pred_df with a column name of col_name_string
  pred_df <- tibble(!!col_name_string := x_seq)
  
  # Predict
  pred_df <- pred_df %>%
    mutate(
      linear_fit  = predict(linear_fit,  newdata = pred_df),
      poly3_fit   = predict(poly3_fit,   newdata = pred_df),
      dau_fit     = predict(dau_fit,     newdata = pred_df),
      logist_fit  = predict(logist_fit,  newdata = pred_df)
    )
  
  # Pivot longer
  plot_pred_df <- pred_df %>%
    pivot_longer(
      cols      = c(linear_fit, poly3_fit,
                    dau_fit,    logist_fit),
      names_to  = "model",
      values_to = "fitted"
    )
  
  ggplot() +
    geom_point(
      data  = dataset_grouped,
      aes(x = .data[[col_name_string]], y = sim_wcr),
      color = "blue", size = 2
    ) +
    geom_line(
      data = plot_pred_df,
      aes(x = .data[[col_name_string]], y = fitted, color = model),
      size = 1
    ) +
    scale_y_continuous(
      name   = "WCR (%)",
      labels = function(x) x * 100
    ) +
    geom_label() +
    scale_color_manual(
      name = "Model Fit",
      values = c(
        "linear_fit" = "yellow",
        "poly3_fit"  = "red",
        "dau_fit"    = "brown",
        "logist_fit" = "purple"
      ),
      labels = c(
        "linear_fit" = paste0("Linear (AICc=",  round(AICc_linear, 2), ")", "(PCC=", round(pcc_linear, 2), ")"),
        "poly3_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")","(PCC=", round(pcc_poly3, 2), ")"),
        "dau_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")","(PCC=", round(pcc_dau, 2), ")"),
        "logist_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")","(PCC=", round(pcc_logist, 2), ")")
      )
    ) + annotate("label_npc", npcx="right", npcy="bottom", label = paste0(expression(tau)," = ", round(ktau,2)), fill = "lightgray") +
    labs(
      title = "Various fits on data grouped by Listening Conditions",
      x     = "MIKNN Score",
      y     = "WCR"
    ) +
    theme_minimal() 
  

}

# Call it like this (note the string):
data_group_by_snr_gender <- allsstar_data %>%
  group_by(snr) %>%
  summarise(
    avg_wcr = mean(sim_wcr),
    avg_stoi_score = mean(stoi_score),
    avg_siib_score_gaussian = mean(siib_score_gaussian_gapped),
    avg_siib_score = mean(siib_score_gaussian_gapped),
    avg_miknn_score = mean(MIKNNScore2x),
    .groups = "drop"
  ) %>% select(where(~ !any(is.na(.)))) %>% mutate(snr = as.factor(snr))

dantale_conds <- dantale_all %>% group_by(cond, snr) %>% summarise(across(everything(), ~ mean(.x, na.rm = TRUE)), .groups = "drop") %>%
  select(where(~ !any(is.na(.)))) %>% mutate(snr = as.factor(snr))

dat_all <- bind_rows(dantale_conds, data_group_by_snr_gender)

dat_allsstar <- data_group_by_snr_gender

final_graphs_raw(allsstar_data, nrow(all_data), "siib_score_gaussian")
final_graphs_raw(dat_allsstar, nrow(dat_allsstar), "avg_stoi_score")
final_graphs_raw(dat_allsstar, nrow(dat_allsstar), "avg_miknn_score")

final_graphs_raw(dat_all, nrow(dat_all), "avg_siib_score_gaussian")
final_graphs_raw(dat_all, nrow(dat_all), "avg_stoi_score")
final_graphs_raw(dat_all, nrow(dat_all), "avg_miknn_score")


# names(dantale_conds)

final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_siib_score_gaussian")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_stoi_score")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_miknn_score")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_SNR")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_SegSNR")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_LLR")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_IS")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_CEP")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_STOI")
final_graphs_raw(dantale_conds, nrow(dantale_conds), "avg_ESTOI")




```

```{r}
 
dantale_conds <- dantale_all %>% group_by(cond, snr) %>% summarise(avg_wcr = mean(avg_wcr), avg_stoi = mean(avg_stoi), avg_siib_gaussian = mean(avg_siib_gaussian), .groups = "drop")



ggplot(dantale_conds, aes(x=avg_stoi, y=avg_wcr, color=snr)) + geom_point()
ggplot(dantale_conds, aes(x=avg_siib_gaussian, y=avg_wcr, color=snr)) + geom_point()



# Fit your models as before...# Fit your models as before...drop()
linear_stoi_fit <- lm(data=dantale_conds, formula=avg_wcr ~ avg_stoi)
poly3_stoi_fit  <- MonoPoly::monpol(formula = avg_wcr ~ avg_stoi, data= dantale_conds, degree = 3)
dau_stoi_fit    <- nlsLM(avg_wcr ~ dau_taal10(avg_stoi, a, b, c),
                          data = dantale_conds,
                          start=c(a=0,b=1,c=0.5))
logist_stoi_fit <- nls(avg_wcr ~ logistic_taal10(avg_stoi, a, b),
                        data = dantale_conds,
                        start=c(a=0,b=0.5))

# Collect predicted values
dantale_conds <- dantale_conds %>%
  mutate(
    poly3_stoi_fit   = predict(poly3_stoi_fit, newdata = dantale_conds),
    dau_stoi_fit     = predict(dau_stoi_fit,   newdata = dantale_conds),
    linear_stoi_fit  = predict(linear_stoi_fit,newdata = dantale_conds),
    logist_stoi_fit  = predict(logist_stoi_fit,newdata = dantale_conds)
  )

# Compute AICc for each model (or BIC if you prefer):
AICc_linear <- AICc(linear_stoi_fit,  n=16, k=2)
AICc_poly3  <- AICc(poly3_stoi_fit,   n=16, k=4)
AICc_dau    <- AICc(dau_stoi_fit,     n=16, k=3)
AICc_logist <- AICc(logist_stoi_fit,  n=16, k=length(coef(logist_stoi_fit)))

# Reshape to long format for easier ggplot usage
plot_data <- dantale_conds %>%
  select(avg_stoi, avg_wcr,
         poly3_stoi_fit,
         dau_stoi_fit,
         linear_stoi_fit,
         logist_stoi_fit) %>%
  pivot_longer(
    cols = c(poly3_stoi_fit, dau_stoi_fit, linear_stoi_fit, logist_stoi_fit),
    names_to = "model",
    values_to = "fitted"
  )

# Now plot with a single geom_line, colored by model
ggplot(plot_data, aes(x = avg_stoi, y = avg_wcr)) +
  geom_point(color="blue", size = 2) +
  geom_line(aes(y = fitted, color = model), size = 1) +
    scale_y_continuous(
    name   = "Average WCR (%)",
    labels = function(x) x * 100
  ) +
  # Put the AICc values (or BIC) into the legend labels:
  scale_color_manual(
    name = "Model Fit",
    values = c(
      "linear_stoi_fit" = "green",
      "poly3_stoi_fit"  = "red",
      "dau_stoi_fit"    = "brown",
      "logist_stoi_fit" = "purple"
    ),
    labels = c(
      "linear_stoi_fit" = paste0("Linear (AICc=", round(AICc_linear, 2), ")"),
      "poly3_stoi_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")"),
      "dau_stoi_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")"),
      "logist_stoi_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")")
    )
  ) +
  labs(
    title = "Various fits on data grouped by SNR and Gender",
    x = "Average stoi",
    y = "Average WCR"
  ) +
  theme_minimal()



```

```{r dantale-siib}
dantale_conds <- dantale_all %>% group_by(cond, snr) %>% summarise(avg_wcr = mean(avg_wcr), avg_stoi = mean(avg_stoi), avg_siib_gaussian = mean(avg_siib_gaussian), .groups = "drop")



# Fit your models as before...# Fit your models as before...drop()
linear_siib_gaussian_fit <- lm(data=dantale_conds, formula=avg_wcr ~ avg_siib_gaussian)
poly3_siib_gaussian_fit  <- MonoPoly::monpol(formula = avg_wcr ~ avg_siib_gaussian, data= dantale_conds, degree = 3)
dau_siib_gaussian_fit    <- nlsLM(avg_wcr ~ dau_taal10(avg_siib_gaussian, a, b, c),
                          data = dantale_conds,
                          start=c(a=0,b=1,c=0.5))
logist_siib_gaussian_fit <- nls(avg_wcr ~ logistic_taal10(avg_siib_gaussian, a, b),
                        data = dantale_conds,
                        start=c(a=0,b=0.5))

# Collect predicted values
dantale_conds <- dantale_conds %>%
  mutate(
    poly3_siib_gaussian_fit   = predict(poly3_siib_gaussian_fit, newdata = dantale_conds),
    dau_siib_gaussian_fit     = predict(dau_siib_gaussian_fit,   newdata = dantale_conds),
    linear_siib_gaussian_fit  = predict(linear_siib_gaussian_fit,newdata = dantale_conds),
    logist_siib_gaussian_fit  = predict(logist_siib_gaussian_fit,newdata = dantale_conds)
  )

# Compute AICc for each model (or BIC if you prefer):
AICc_linear <- AICc(linear_siib_gaussian_fit,  n=16, k=length(coef(linear_siib_gaussian_fit)))
AICc_poly3  <- AICc(poly3_siib_gaussian_fit,   n=16, k=length(coef(poly3_siib_gaussian_fit)))
AICc_dau    <- AICc(dau_siib_gaussian_fit,     n=16, k=length(coef(dau_siib_gaussian_fit)))
AICc_logist <- AICc(logist_siib_gaussian_fit,  n=16, k=length(coef(logist_siib_gaussian_fit)))

# Reshape to long format for easier ggplot usage
plot_data <- dantale_conds %>%
  select(avg_siib_gaussian, avg_wcr,
         poly3_siib_gaussian_fit,
         dau_siib_gaussian_fit,
         linear_siib_gaussian_fit,
         logist_siib_gaussian_fit) %>%
  pivot_longer(
    cols = c(poly3_siib_gaussian_fit, dau_siib_gaussian_fit, linear_siib_gaussian_fit, logist_siib_gaussian_fit),
    names_to = "model",
    values_to = "fitted"
  )

# Now plot with a single geom_line, colored by model
ggplot(plot_data, aes(x = avg_siib_gaussian, y = avg_wcr)) +
  geom_point(color="blue", size = 2) +
  geom_line(aes(y = fitted, color = model), size = 1) +
    scale_y_continuous(
    name   = "Average WCR (%)",
    labels = function(x) x * 100
  ) +
  # Put the AICc values (or BIC) into the legend labels:
  scale_color_manual(
    name = "Model Fit",
    values = c(
      "linear_siib_gaussian_fit" = "green",
      "poly3_siib_gaussian_fit"  = "red",
      "dau_siib_gaussian_fit"    = "brown",
      "logist_siib_gaussian_fit" = "purple"
    ),
    labels = c(
      "linear_siib_gaussian_fit" = paste0("Linear (AICc=", round(AICc_linear, 2), ")"),
      "poly3_siib_gaussian_fit"  = paste0("P.1401 third order poly (AICc=", round(AICc_poly3, 2), ")"),
      "dau_siib_gaussian_fit"    = paste0("DAU Taal10 (AICc=", round(AICc_dau, 2), ")"),
      "logist_siib_gaussian_fit" = paste0("Logistic (AICc=", round(AICc_logist, 2), ")")
    )
  ) +
  labs(
    title = "Various fits on data grouped by SNR and Gender",
    x = "Average siib_gaussian",
    y = "Average WCR"
  ) +
  theme_minimal()



ggplot(dantale_conds, aes(x=avg_stoi, y=avg_wcr, color=snr)) + geom_point()
ggplot(dantale_conds, aes(x=avg_siib_gaussian, y=avg_wcr, color=snr)) + geom_point()


```

# GPT again
```{r gpt-finalgraph}

model_specs <- list(
  linear = list(
    method       = "lm",
    formula_expr = quote(y ~ x)  # 'quote()' so we can substitute later
  ),
  monpoly3 = list(
    method       = "monpol",
    formula_expr = quote(y ~ x),
    degree       = 3
  ),
  logistic = list(
    method       = "nls",
    formula_expr = quote(y ~ logistic_taal10(x, a, b)),
    start        = c(a = 0, b = 0.5)
  ),
  gompertz = list(
    method       = "nls",
    formula_expr = quote(y ~ gomp(x, 1, b, c)),
    start        = c(b=1, c=-0.01)
  )
  
)

library(dplyr)
library(tidyr)
library(ggplot2)
library(MonoPoly)       # for monpol()
library(minpack.lm)     # for nlsLM if you want it
library(LaplacesDemon)  # for AICc()
library(cv)

fit_many_models <- function(data, x_col, y_col, model_list, n = nrow(data)) {
  # data: your data frame
  # x_col, y_col: strings for the x and y columns in `data`
  # model_list: the named list of model specs
  # n: number of data points (used in AICc)
  
  # We’ll store:
  # 1) A data frame of model performance metrics
  # 2) A data frame of predictions (in "long" format for ggplot)
  
  # 1. Prepare an empty container for each model’s summary
  model_summaries <- list()
  
  # 2. Prepare a container for predicted curves
  #    We'll build it as we go, or initialize after we have predictions.
  
  # Build a formula-friendly expression from user’s x_col, y_col
  # We'll do something like:  y_col ~ x_col  inside each specification
  # but the user might specify something more advanced (poly, etc.)
  # So we’ll do it via substituting x->(x_col) and y->(y_col) in the quoted expression.
  
  # This function: Substitutes the symbol 'x' with x_col, 'y' with y_col, etc.
  make_formula <- function(expr, x_sym, y_sym) {
    # e.g., expr = quote(y ~ log(x)), x_sym=as.symbol("avg_stoi_score"), etc.
    # Then we evaluate it into an actual formula object.
    call_mod <- eval(substitute(
      substitute(EXPR, list(x = x_sym, y = y_sym)), 
      list(EXPR = expr)
    ))
    # call_mod is now something like `y_col ~ log(x_col)` as a call
    # Turn it into a formula
    as.formula(call_mod)
  }
  
  # 3. We will define a grid of x-values for plotting predictions
  x_vals <- seq(min(data[[x_col]], na.rm = TRUE),
                max(data[[x_col]], na.rm = TRUE),
                length.out = 200)
  
  # Build a “prediction data frame” with the same column name as `x_col`
  pred_df <- data.frame(x_vals)
  names(pred_df) <- x_col
  
  # We’ll build up columns in pred_df for each model’s predicted Y.
  
  for (model_name in names(model_list)) {
    spec <- model_list[[model_name]]
  
    
    # We expect:
    #   spec$method in c("lm","nls","nlsLM","monpol", etc.)
    #   spec$formula_expr is a quoted expression like y ~ x, y ~ logistic_taal10(x,a,b), etc.
    #   Maybe spec$degree for monpol
    #   Maybe spec$start for nls
    
    # 1. Construct the formula from spec$formula_expr
    fmla <- make_formula(spec$formula_expr,
                         x_sym = as.symbol(x_col),
                         y_sym = as.symbol(y_col))
    
    # 2. Fit the model
    fit_obj <- NULL
    if (spec$method == "lm") {
      fit_obj <- lm(fmla, data = data)
    } else if (spec$method == "monpol") {
      # monpol uses "fmla", "degree", and possibly other arguments
      fit_obj <- monpol(fmla, data = data, degree = spec$degree)
    } else if (spec$method == "nls") {
      fit_obj <- nls(fmla, data = data, start = spec$start)
    } else if (spec$method == "nlsLM") {
      fit_obj <- nlsLM(fmla, data = data, start = spec$start)
    } else {
      stop("Unsupported fitting method: ", spec$method)
    }
    
    print(paste("Cv:", spec$method, str(cv(fit_obj, k=2))))
    fmla <- make_formula(spec$formula_expr,
                         x_sym = as.symbol(x_col),
                         y_sym = as.symbol(y_col))
    print(paste("Coefs:", spec$method, str(coef(fit_obj))))
    
    # 3. Compute metrics: RMSE, AIC, AICc, PCC, etc.
    #    We'll define a small helper for predictions
    pred_obj <- predict(fit_obj, newdata = data)
    
    # monpol returns a data frame with columns x and y
    # others return a numeric vector
    if (spec$method == "monpol") {
      preds <- c(pred_obj)
      obs <- data[[y_col]]  # monpol returns a data frame
    } else {
      preds <- pred_obj
      obs <- data[[y_col]]
    } 

    rmse <- sqrt(mean((obs - preds)^2, na.rm = TRUE))
    aic  <- AIC(fit_obj)
    
    # For number of parameters k, we can approximate with length(coef(fit_obj)).
    k    <- length(coef(fit_obj))
    aicc <- AICc(fit_obj, n = n, k = k)
    
    pcc <- cor(obs, preds, use = "complete.obs")  # Pearson corr
    # Kendall’s tau (optional)
    ktau <- cor(obs, preds, method = "kendall", use = "complete.obs")
    
    # Collect results
    model_summaries[[model_name]] <- data.frame(
      Model       = model_name,
      Method      = spec$method,
      RMSE        = rmse,
      AIC         = aic,
      AICc        = aicc,
      PCC         = pcc,
      KendallTau  = ktau,
      stringsAsFactors = FALSE
    )
    
    
    # 4. Add predictions for the *new grid* of x-values
    pred_colname <- paste0(model_name, "_pred")
    pred_df[[pred_colname]] <- predict(fit_obj, newdata = pred_df)
  }
  
  # Combine the model summaries
  summary_df <- do.call(rbind, model_summaries)
  
  # We can also compute the minimum AICc and get ΔAICc, etc.
  min_aicc <- min(summary_df$AICc)
  summary_df <- summary_df %>%
    mutate(dAICc = AICc - min_aicc,
           relLik = exp(-0.5 * dAICc),
           weight = relLik / sum(relLik))
  
  # Now pivot the pred_df from wide to long for plotting
  # pred_df has columns: x_col, model1_pred, model2_pred, ...
  long_pred_df <- pred_df %>%
    tidyr::pivot_longer(
      cols = -all_of(x_col),
      names_to = "Model",
      values_to = "FittedValue"
    )
  
  # Return a list with everything we might want
  list(
    summary    = summary_df,
    predictions = long_pred_df
  )
}

# Example usage:
res <- fit_many_models(
  data       = dantale_all,
  x_col      = "avg_miknn_score",
  y_col      = "avg_wcr",
  model_list = model_specs,
  n          = nrow(allsstar_data)
)

# Check the summary:
res$summary

#        Model   Method     RMSE      AIC     AICc       PCC KendallTau    dAICc     relLik     weight
# 1     linear       lm   0.0852  10.1234  10.5811  ...   ...  
# 2   monpoly3   monpol   0.0821   9.9981  10.2234  ...   ...
# 3   logistic      nls   0.0760   6.1235   7.0012  ...   ...
# 4  gompertz      nls    0.0778   7.5233   7.9900  ...   ...
# etc.

# For plotting:
long_pred <- res$predictions


    data_sum  = allsstar_data %>% group_by(sim_wcr) %>% summarize(stoi_score = mean(stoi_score), snr = mean(snr))

    
    ##!!!!!
ggplot() +
  geom_point(
    data  = data_sum,
    aes(x = sim_wcr, y = stoi_score, color = snr)
  ) 


ggplot() +
  geom_point(
    data  = data_sum,
    aes(x = snr, y = sim_wcr, color = stoi_score)
  ) 



  geom_line(
    data = long_pred,
    aes_string(x = "avg_stoi_score", y = "FittedValue", color = "Model"),
    linewidth = 1
  ) +
  labs(
    x = "STOI Score",
    y = "WCR (%)",
    color = "Model"
  ) +
  theme_minimal()


```
